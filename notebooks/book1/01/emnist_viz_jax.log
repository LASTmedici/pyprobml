An error occurred while executing the following cell:
------------------
transform = transforms.Compose(
    [lambda img: torchvision.transforms.functional.rotate(img, 90), transforms.ToTensor(), jnp.array]
)

training_data = datasets.EMNIST(root="~/data", split="byclass", download=True, transform=transform)
------------------

---------------------------------------------------------------------------
HTTPError                                 Traceback (most recent call last)
/tmp/ipykernel_5390/3159456905.py in <module>
      3 )
      4 
----> 5 training_data = datasets.EMNIST(root="~/data", split="byclass", download=True, transform=transform)

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/mnist.py in __init__(self, root, split, **kwargs)
    295         self.training_file = self._training_file(split)
    296         self.test_file = self._test_file(split)
--> 297         super().__init__(root, **kwargs)
    298         self.classes = self.classes_split_dict[self.split]
    299 

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/mnist.py in __init__(self, root, train, transform, target_transform, download)
     97 
     98         if download:
---> 99             self.download()
    100 
    101         if not self._check_exists():

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/mnist.py in download(self)
    332         os.makedirs(self.raw_folder, exist_ok=True)
    333 
--> 334         download_and_extract_archive(self.url, download_root=self.raw_folder, md5=self.md5)
    335         gzip_folder = os.path.join(self.raw_folder, "gzip")
    336         for gzip_file in os.listdir(gzip_folder):

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/utils.py in download_and_extract_archive(url, download_root, extract_root, filename, md5, remove_finished)
    444         filename = os.path.basename(url)
    445 
--> 446     download_url(url, download_root, filename, md5)
    447 
    448     archive = os.path.join(download_root, filename)

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/utils.py in download_url(url, root, filename, md5, max_redirect_hops)
    144     else:
    145         # expand redirect chain if needed
--> 146         url = _get_redirect_url(url, max_hops=max_redirect_hops)
    147 
    148         # check if file is located on Google Drive

~/miniconda3/envs/py37/lib/python3.7/site-packages/torchvision/datasets/utils.py in _get_redirect_url(url, max_hops)
     92 
     93     for _ in range(max_hops + 1):
---> 94         with urllib.request.urlopen(urllib.request.Request(url, headers=headers)) as response:
     95             if response.url == url or response.url is None:
     96                 return url

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in urlopen(url, data, timeout, cafile, capath, cadefault, context)
    220     else:
    221         opener = _opener
--> 222     return opener.open(url, data, timeout)
    223 
    224 def install_opener(opener):

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in open(self, fullurl, data, timeout)
    529         for processor in self.process_response.get(protocol, []):
    530             meth = getattr(processor, meth_name)
--> 531             response = meth(req, response)
    532 
    533         return response

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in http_response(self, request, response)
    639         if not (200 <= code < 300):
    640             response = self.parent.error(
--> 641                 'http', request, response, code, msg, hdrs)
    642 
    643         return response

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in error(self, proto, *args)
    567         if http_err:
    568             args = (dict, 'default', 'http_error_default') + orig_args
--> 569             return self._call_chain(*args)
    570 
    571 # XXX probably also want an abstract factory that knows when it makes

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in _call_chain(self, chain, kind, meth_name, *args)
    501         for handler in handlers:
    502             func = getattr(handler, meth_name)
--> 503             result = func(*args)
    504             if result is not None:
    505                 return result

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in http_error_default(self, req, fp, code, msg, hdrs)
    647 class HTTPDefaultErrorHandler(BaseHandler):
    648     def http_error_default(self, req, fp, code, msg, hdrs):
--> 649         raise HTTPError(req.full_url, code, msg, hdrs, fp)
    650 
    651 class HTTPRedirectHandler(BaseHandler):

HTTPError: HTTP Error 503: Service Unavailable
HTTPError: HTTP Error 503: Service Unavailable
