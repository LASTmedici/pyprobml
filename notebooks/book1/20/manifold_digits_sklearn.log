An error occurred while executing the following cell:
------------------
# Modified from
# https://scikit-learn.org/stable/auto_examples/manifold/plot_lle_digits.html
"""
An illustration of various embeddings on the UCI digits dataset.

UMAP and t-SNE do not use label information.
t-SNE will be initialized with the embedding that is generated by PCA in this example, which is not the default setting.
 It ensures global stability of the embedding, i.e., the embedding does not depend on random initialization.

Linear Discriminant Analysis, from the sklearn.discriminant_analysis module, and Neighborhood Components Analysis,
from the sklearn.neighbors module, are supervised dimensionality reduction method, i.e. they make use of the provided labels, contrary to other methods.
"""

# Authors: Fabian Pedregosa <fabian.pedregosa@inria.fr>
#          Olivier Grisel <olivier.grisel@ensta.org>
#          Mathieu Blondel <mathieu@mblondel.org>
#          Gael Varoquaux
# License: BSD 3 clause (C) INRIA 2011

figdir = "figures"

import os

try:
    from probml_utils import savefig
except ModuleNotFoundError:
    %pip install -qq git+https://github.com/probml/probml-utils.git
    from probml_utils import savefig


from time import time

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import offsetbox

from sklearn import manifold, datasets, decomposition, ensemble, discriminant_analysis, random_projection, neighbors

try:
    import umap  # # https://github.com/lmcinnes/umap
except ModuleNotFoundError:
    %pip install -qq umap-learn
    import umap  # # https://github.com/lmcinnes/umap

digits = datasets.load_digits()  # n_class=6)
X = digits.data
y = digits.target  # 0..9
n_samples, n_features = X.shape
n_neighbors = 30


# ----------------------------------------------------------------------
# Scale and visualize the embedding vectors
def plot_embedding(X, title=None):
    x_min, x_max = np.min(X, 0), np.max(X, 0)
    X = (X - x_min) / (x_max - x_min)

    plt.figure()
    ax = plt.subplot(111)
    for i in range(X.shape[0]):
        # color=y[i] / 10.0
        color = (y[i] + 1) / 11.0  # ensure each digit gets unique color
        plt.text(X[i, 0], X[i, 1], str(y[i]), color=plt.cm.Set1(color), fontdict={"weight": "bold", "size": 9})

    if hasattr(offsetbox, "AnnotationBbox"):
        # only print thumbnails with matplotlib > 1.0
        shown_images = np.array([[1.0, 1.0]])  # just something big
        for i in range(X.shape[0]):
            dist = np.sum((X[i] - shown_images) ** 2, 1)
            if np.min(dist) < 4e-3:
                # don't show points that are too close
                continue
            shown_images = np.r_[shown_images, [X[i]]]
            imagebox = offsetbox.AnnotationBbox(offsetbox.OffsetImage(digits.images[i], cmap=plt.cm.gray_r), X[i])
            ax.add_artist(imagebox)
    plt.xticks([]), plt.yticks([])
    if title is not None:
        plt.title(title)


# ----------------------------------------------------------------------
# Plot images of the digits
n_img_per_row = 20
img = np.zeros((10 * n_img_per_row, 10 * n_img_per_row))
for i in range(n_img_per_row):
    ix = 10 * i + 1
    for j in range(n_img_per_row):
        iy = 10 * j + 1
        img[ix : ix + 8, iy : iy + 8] = X[i * n_img_per_row + j].reshape((8, 8))

plt.imshow(img, cmap=plt.cm.binary)
plt.xticks([])
plt.yticks([])
# plt.title('A selection from the 64-dimensional digits dataset')
savefig("manifold_digits_data.pdf")


# ----------------------------------------------------------------------

print("Computing UMAP projection")
X_umap = umap.UMAP(n_neighbors=5, min_dist=0.3, n_components=2, metric="correlation").fit_transform(X)
plot_embedding(X_umap, "UMAP projection")
savefig("manifold_digits_umap.pdf")
plt.show()


# ----------------------------------------------------------------------
# Projection on to the first 2 principal components

print("Computing PCA projection")
X_pca = decomposition.TruncatedSVD(n_components=2).fit_transform(X)
plot_embedding(X_pca, "Principal Components projection")
savefig("manifold_digits_pca.pdf")
plt.show()

# ----------------------------------------------------------------------
# Projection on to the first 2 linear discriminant components

print("Computing Linear Discriminant Analysis projection")
X2 = X.copy()
X2.flat[:: X.shape[1] + 1] += 0.01  # Make X invertible
X_lda = discriminant_analysis.LinearDiscriminantAnalysis(n_components=2).fit_transform(X2, y)
plot_embedding(X_lda, "Linear Discriminant projection")
savefig("manifold_digits_lda.pdf")
plt.show()

# ----------------------------------------------------------------------
# MDS  embedding of the digits dataset
print("Computing MDS embedding")
clf = manifold.MDS(n_components=2, n_init=1, max_iter=100)
X_mds = clf.fit_transform(X)
print("Done. Stress: %f" % clf.stress_)
plot_embedding(X_mds, "MDS embedding")
savefig("manifold_digits_mds.pdf")
plt.show()

# ----------------------------------------------------------------------
# t-SNE embedding of the digits dataset
print("Computing t-SNE embedding")
tsne = manifold.TSNE(n_components=2, init="pca", random_state=0)
X_tsne = tsne.fit_transform(X)
plot_embedding(X_tsne, "t-SNE embedding")
savefig("manifold_digits_tsne.pdf")
plt.show()

# ----------------------------------------------------------------------
# Spectral embedding of the digits dataset
print("Computing Spectral embedding")
embedder = manifold.SpectralEmbedding(n_components=2, random_state=0, eigen_solver="arpack")
X_se = embedder.fit_transform(X)
plot_embedding(X_se, "Spectral embedding")
savefig("manifold_digits_SE.pdf")
plt.show()

# ----------------------------------------------------------------------
# Locally linear embedding of the digits dataset
print("Computing LLE embedding")
embedder = manifold.LocallyLinearEmbedding(n_neighbors=n_neighbors, n_components=2, method="standard")
X_lle = embedder.fit_transform(X)
plot_embedding(X_lle, "Locally Linear Embedding")
savefig("manifold_digits_LLE.pdf")
plt.show()

# ----------------------------------------------------------------------
# Isomap projection of the digits dataset
print("Computing Isomap projection")
X_iso = manifold.Isomap(n_neighbors=n_neighbors, n_components=2).fit_transform(X)
plot_embedding(X_iso, "Isomap")
savefig("manifold_digits_isomap.pdf")
plt.show()

# ----------------------------------------------------------------------
from sklearn.decomposition import KernelPCA

print("Computing kPCA")
transformer = KernelPCA(n_components=2, kernel="rbf", gamma=10)
X_kpca = transformer.fit_transform(X)
plot_embedding(X_kpca, "kPCA")
savefig("manifold_digits_kPCA.pdf")
plt.show()
------------------

---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
/tmp/ipykernel_5652/3727510768.py in <module>
     38 
     39 try:
---> 40     import umap  # # https://github.com/lmcinnes/umap
     41 except ModuleNotFoundError:
     42     get_ipython().run_line_magic('pip', 'install -qq umap-learn')

~/miniconda3/envs/py37/lib/python3.7/site-packages/umap/__init__.py in <module>
      5     with catch_warnings():
      6         simplefilter("ignore")
----> 7         from .parametric_umap import ParametricUMAP
      8 except ImportError:
      9     warn(

~/miniconda3/envs/py37/lib/python3.7/site-packages/umap/parametric_umap.py in <module>
     12 
     13 try:
---> 14     import tensorflow as tf
     15 except ImportError:
     16     warn(

~/miniconda3/envs/py37/lib/python3.7/site-packages/tensorflow/__init__.py in <module>
    471 if hasattr(_current_module, "keras"):
    472   try:
--> 473     keras._load()
    474   except ImportError:
    475     pass

~/miniconda3/envs/py37/lib/python3.7/site-packages/tensorflow/python/util/lazy_loader.py in _load(self)
     39     """Load the module and insert it into the parent's globals."""
     40     # Import the target module and insert it into the parent's namespace
---> 41     module = importlib.import_module(self.__name__)
     42     self._parent_module_globals[self._local_name] = module
     43 

~/miniconda3/envs/py37/lib/python3.7/importlib/__init__.py in import_module(name, package)
    125                 break
    126             level += 1
--> 127     return _bootstrap._gcd_import(name[level:], package, level)
    128 
    129 

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/__init__.py in <module>
     23 
     24 # See b/110718070#comment18 for more details about this import.
---> 25 from keras import models
     26 
     27 from keras.engine.input_layer import Input

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/models/__init__.py in <module>
     16 
     17 
---> 18 from keras.engine.functional import Functional
     19 from keras.engine.sequential import Sequential
     20 from keras.engine.training import Model

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/engine/functional.py in <module>
     23 import warnings
     24 from keras import backend
---> 25 from keras.engine import base_layer
     26 from keras.engine import base_layer_utils
     27 from keras.engine import functional_utils

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/engine/base_layer.py in <module>
     41 from keras.engine import node as node_module
     42 from keras.mixed_precision import autocast_variable
---> 43 from keras.mixed_precision import loss_scale_optimizer
     44 from keras.mixed_precision import policy
     45 from keras.saving.saved_model import layer_serialization

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/mixed_precision/loss_scale_optimizer.py in <module>
     18 from keras import optimizers
     19 from keras.mixed_precision import loss_scale as keras_loss_scale_module
---> 20 from keras.optimizer_experimental import optimizer as optimizer_experimental
     21 from keras.optimizer_v2 import optimizer_v2
     22 from keras.optimizer_v2 import utils as optimizer_utils

~/miniconda3/envs/py37/lib/python3.7/site-packages/keras/optimizer_experimental/optimizer.py in <module>
    655             version=2,
    656             min_producer_version=1,
--> 657             min_consumer_version=1)
    658     ])

~/miniconda3/envs/py37/lib/python3.7/site-packages/tensorflow/python/saved_model/revived_types.py in register_revived_type(identifier, predicate, versions)
    131 
    132   if identifier in _REVIVED_TYPE_REGISTRY:
--> 133     raise AssertionError(f"Duplicate registrations for type '{identifier}'")
    134 
    135   _REVIVED_TYPE_REGISTRY[identifier] = (predicate, versions)

AssertionError: Duplicate registrations for type 'experimentalOptimizer'
AssertionError: Duplicate registrations for type 'experimentalOptimizer'
