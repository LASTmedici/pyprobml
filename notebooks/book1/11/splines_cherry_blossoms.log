An error occurred while executing the following cell:
------------------
# splines in 1d
# We use the cherry blossom daa from sec 4.5 of "Statistical Rethinking"
# We use temperature as the target variable, to match a draft version of the book,
# https://github.com/Booleans/statistical-rethinking/blob/master/Statistical%20Rethinking%202nd%20Edition.pdf
# The published version uses  day of year as target, which is less visually interesting.
# This an MLE version of the Bayesian numpyro code from
# https://fehiepsi.github.io/rethinking-numpyro/04-geocentric-models.html


import numpy as np

np.set_printoptions(precision=3)
import matplotlib.pyplot as plt
import math
import os
import warnings

try:
    import pandas as pd
except ModuleNotFoundError:
    %pip install -qq pandas
    import pandas as pd

from scipy.interpolate import BSpline

from scipy import stats

try:
    from patsy import bs, dmatrix
except ModuleNotFoundError:
    %pip install -qq patsy
    from patsy import bs, dmatrix

try:
    import sklearn
except ModuleNotFoundError:
    %pip install -qq scikit-learn
    import sklearn
from sklearn.linear_model import LinearRegression, Ridge


# https://stackoverflow.com/questions/61807542/generate-a-b-spline-basis-in-scipy-like-bs-in-r


def make_splines_scipy(x, num_knots, degree=3):
    knot_list = np.quantile(x, q=np.linspace(0, 1, num=num_knots))
    knots = np.pad(knot_list, (3, 3), mode="edge")
    B = BSpline(knots, np.identity(num_knots + 2), k=degree)(x)
    # according to scipy documentation
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BSpline.html
    # if degree = k, ncoef = n,  nknots = n + k + 1
    # so if k=3, ncoef = nknots - 4
    # where nknots = num_knot + 6 (because of 3 pad on left, 3 on right)
    # so ncoef= num_knots + 6 - 4 = num_knots + 2
    return B


def make_splines_patsy(x, num_knots, degree=3):
    knot_list = np.quantile(x, q=np.linspace(0, 1, num=num_knots))
    # B  = bs(x, knots=knot_list, degree=degree)  # ncoef = knots + degree + 1
    B = bs(x, df=num_knots, degree=degree)  # uses quantiles
    return B


def plot_basis(x, B, w=None):
    if w is None:
        w = np.ones((B.shape[1]))
    fig, ax = plt.subplots()
    ax.set_xlim(np.min(x), np.max(x))
    for i in range(B.shape[1]):
        ax.plot(x, (w[i] * B[:, i]), "k", alpha=0.5)
    return ax


def plot_basis_with_vertical_line(x, B, xstar):
    ax = plot_basis(x, B)
    num_knots = B.shape[1]
    ndx = np.where(x == xstar)[0][0]
    for i in range(num_knots):
        yy = B[ndx, i]
        if yy > 0:
            ax.scatter(xstar, yy, s=40)
    ax.axvline(x=xstar)
    return ax


def plot_pred(mu, x, y):
    plt.figure()
    plt.scatter(x, y, alpha=0.5)
    plt.plot(x, mu, "k-", linewidth=4)


def main():
    url = "https://raw.githubusercontent.com/fehiepsi/rethinking-numpyro/master/data/cherry_blossoms.csv"
    cherry_blossoms = pd.read_csv(url, sep=";")
    df = cherry_blossoms

    display(df.sample(n=5, random_state=1))
    display(df.describe())

    df2 = df[df.temp.notna()]  # complete cases
    x = df2.year.values.astype(float)
    y = df2.temp.values.astype(float)
    xlabel = "year"
    ylabel = "temp"

    nknots = 15

    # B =  make_splines_scipy(x, nknots)
    B = make_splines_patsy(x, nknots)
    print(B.shape)
    plot_basis_with_vertical_line(x, B, 1200)
    plt.tight_layout()
    plt.savefig(f"figures/splines_basis_vertical_MLE_{nknots}_{ylabel}.pdf", dpi=300)

    # reg = LinearRegression().fit(B, y)
    reg = Ridge().fit(B, y)
    w = reg.coef_
    a = reg.intercept_
    print(w)
    print(a)

    plot_basis(x, B, w)
    plt.tight_layout()
    plt.savefig(f"figures/splines_basis_weighted_MLE_{nknots}_{ylabel}.pdf", dpi=300)

    mu = a + B @ w
    plot_pred(mu, x, y)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.tight_layout()
    plt.savefig(f"figures/splines_point_pred_MLE_{nknots}_{ylabel}.pdf", dpi=300)


main()
------------------

---------------------------------------------------------------------------
HTTPError                                 Traceback (most recent call last)
/tmp/ipykernel_4734/2037117048.py in <module>
    133 
    134 
--> 135 main()

/tmp/ipykernel_4734/2037117048.py in main()
     93 def main():
     94     url = "https://raw.githubusercontent.com/fehiepsi/rethinking-numpyro/master/data/cherry_blossoms.csv"
---> 95     cherry_blossoms = pd.read_csv(url, sep=";")
     96     df = cherry_blossoms
     97 

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    309                     stacklevel=stacklevel,
    310                 )
--> 311             return func(*args, **kwargs)
    312 
    313         return wrapper

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/readers.py in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, error_bad_lines, warn_bad_lines, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options)
    584     kwds.update(kwds_defaults)
    585 
--> 586     return _read(filepath_or_buffer, kwds)
    587 
    588 

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/readers.py in _read(filepath_or_buffer, kwds)
    480 
    481     # Create the parser.
--> 482     parser = TextFileReader(filepath_or_buffer, **kwds)
    483 
    484     if chunksize or iterator:

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/readers.py in __init__(self, f, engine, **kwds)
    809             self.options["has_index_names"] = kwds["has_index_names"]
    810 
--> 811         self._engine = self._make_engine(self.engine)
    812 
    813     def close(self):

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/readers.py in _make_engine(self, engine)
   1038             )
   1039         # error: Too many arguments for "ParserBase"
-> 1040         return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]
   1041 
   1042     def _failover_to_python(self):

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/c_parser_wrapper.py in __init__(self, src, **kwds)
     49 
     50         # open handles
---> 51         self._open_handles(src, kwds)
     52         assert self.handles is not None
     53 

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/parsers/base_parser.py in _open_handles(self, src, kwds)
    227             memory_map=kwds.get("memory_map", False),
    228             storage_options=kwds.get("storage_options", None),
--> 229             errors=kwds.get("encoding_errors", "strict"),
    230         )
    231 

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/common.py in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)
    612         compression=compression,
    613         mode=mode,
--> 614         storage_options=storage_options,
    615     )
    616 

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/common.py in _get_filepath_or_buffer(filepath_or_buffer, encoding, compression, mode, storage_options)
    310         # assuming storage_options is to be interpreted as headers
    311         req_info = urllib.request.Request(filepath_or_buffer, headers=storage_options)
--> 312         with urlopen(req_info) as req:
    313             content_encoding = req.headers.get("Content-Encoding", None)
    314             if content_encoding == "gzip":

~/miniconda3/envs/py37/lib/python3.7/site-packages/pandas/io/common.py in urlopen(*args, **kwargs)
    210     import urllib.request
    211 
--> 212     return urllib.request.urlopen(*args, **kwargs)
    213 
    214 

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in urlopen(url, data, timeout, cafile, capath, cadefault, context)
    220     else:
    221         opener = _opener
--> 222     return opener.open(url, data, timeout)
    223 
    224 def install_opener(opener):

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in open(self, fullurl, data, timeout)
    529         for processor in self.process_response.get(protocol, []):
    530             meth = getattr(processor, meth_name)
--> 531             response = meth(req, response)
    532 
    533         return response

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in http_response(self, request, response)
    639         if not (200 <= code < 300):
    640             response = self.parent.error(
--> 641                 'http', request, response, code, msg, hdrs)
    642 
    643         return response

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in error(self, proto, *args)
    567         if http_err:
    568             args = (dict, 'default', 'http_error_default') + orig_args
--> 569             return self._call_chain(*args)
    570 
    571 # XXX probably also want an abstract factory that knows when it makes

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in _call_chain(self, chain, kind, meth_name, *args)
    501         for handler in handlers:
    502             func = getattr(handler, meth_name)
--> 503             result = func(*args)
    504             if result is not None:
    505                 return result

~/miniconda3/envs/py37/lib/python3.7/urllib/request.py in http_error_default(self, req, fp, code, msg, hdrs)
    647 class HTTPDefaultErrorHandler(BaseHandler):
    648     def http_error_default(self, req, fp, code, msg, hdrs):
--> 649         raise HTTPError(req.full_url, code, msg, hdrs, fp)
    650 
    651 class HTTPRedirectHandler(BaseHandler):

HTTPError: HTTP Error 503: first byte timeout
HTTPError: HTTP Error 503: first byte timeout
